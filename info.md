# IOS 정보 


## ARC(Automatic Reference Counting)
- 자동 참조 계수라고 하며 앱의 메모리 사용을 추적하고 관리하기 위해 사용한다.
- ARC는 인스턴스가 더이상 필요가 없을 때 클래스 인스턴스에 사용된 메모리를 자동적으로 해제한다.
- 코드를 빌드(컴파일) 할때 특정 객체의 레퍼런스 카운트를 추적하여 0 가 되는 시점에 자동으로 release 코드를 넣어주는것을 말한다.
- 컴파일 시점에 동작한다.

## strong, weak, unowned

### strong(강한 참조)
- 이 키워드로 선언된 레퍼런스 객체는 할당되는 순간 해당 객체의 레퍼런스 카운트를 증가시킨다.
- 레퍼런스 카운트를 증가시켜 ARC로 인한 메모리 해제를 피하고 객체를 안전하게 사용하기 위해 쓰인다.
- 값 지정 시점에 retain이 되고 참조가 종료되는 시점에 release가 된다.

### weak(약한 참조)
- 객체를 소유하지 않고 주소값만을 가지고 있는 포인터 개념이다.
- 객체가 할당될 때 레퍼런스 카운트를 증가시키지 않는다.
- 이 키워드는 Optional 타입에만 적용이 된다.
- 객체가 ARC 에 의해 메모리해제되면 nil 값이 할당된다.
- 대표적으로 retain cycle 에 의해 메모리가 누수되는 문제를 막기 위해 사용됨, iOS 프레임워크에서 이의 대표적인 예로는 Delegate 패턴이 있다.

### unowned(미소유 참조)
- 객체가 할당될 때 레퍼런스 카운트를 증가시키지 않는다.
- Non-Optional 타입으로 선언되어야 한다.
- 객체가 ARC에 의해 메모리가 해제되더라도 해당 객체 값을 존재하는 것으로 인지, 해당 객체에 엑세스 할 경우 런타임 오류를 발생시킨다.

## 객체간 순환참조를 발견하는 방법과 해결방법
- Xcode Memory Graph 이용해서 Live Object 들을 확인하고, Leak 된 Object 를 체크.
- Instrument 의 Leak 도구를 이용하여 체크.
- deinit 을 활용하여 로깅코드를 통해 체크.

## Escaping Closure
- 클로저가 함수로부터 Escape 한다는 것은 해당 함수의 인자로 클로저가 전달되지만, 함수가 반환된 후 실행되는것을 의미.
- 클로저를 매개변수로 갖는 함수를 선언할 때 매개 변수의 이름의 콜론 뒤에 @escaping 키워드를 사용하여 클로저가 탈출하는 것을 허용한다고 명시
- 클로저가 함수를 탈출할 수 있는 경우 중 하나는 함수 외부에 정의된 변수나 상수에 저장되어 함수가 종료된 후에 사용할 경우.
- 비동기 작업을 해야하는 많은 함수들은 completion handler 매개변수로 클로저를 받는다. 해당 클로저는 함수의 작업이 완료될 때 까지 호출되지 않는다. 즉, completion handler 는 함수의 작업이 완료된 후 호출되는 것을 보장받을 수 있다.
- @escaping으로 표기된 클로저는 외부 값을 참조할 때 self 를 명시해야 합니다.

## 타입캐스팅 as, as!, as?

### as
- 컴파일러가 타입 변환의 성공을 보장한다.
- 컴파일 타임에 가능/불가능 여부를 알 수 있다.

### as!
- 타입 변환에 실패하는 경우 실행시간(Runtime)오류를 발생시킨다.
- 컴파일 타임에  가능/불가능 여부를 알 수 없다.

### as?
- 타입 변환에 실패하는 경우 nil을 리턴
- 컴파일 타임에 가능/불가능 여부를 알 수 없다.

## Class와 Struct
### Class
- Reference Type
- 객체화 시 힙 메모리 영역에 저장되며 ARC로 객체의 메모리해제가 관리된다.
- 대입 연산 시 레퍼런스가 복사되어 할당된다. (공유가 가능하다)
- 멀티스레딩 시 적절한 Lock활용이 필요하다.
- 상속이 가능하다.

### Struct
- Value Type
- 대입 연산 시 값 자체가 복제되어 할당된다. (공유가 불가능하다)
- 불변성 구현에 유리하다.
- 멀티스레딩에 안전하다.
- 상속이 불가능하다. (protocol은 사용가능)

## Frame과 Bounds

### Frame
- SuperView(상위뷰) 좌표시스템 내에서의 View의 위치와 크기

### Bounds
- View 자기 자신의 좌표시스템에서의 위치와 크기
- 부모 View와의 위치관계와는 아무런 관계가 없다.
- 자기자신의 좌표시스템을 가리키기 때문에 기본적으로 origin은 x:0, y:0을 가리킨다.
- Bounds의 origin을 변경한다는 것은 SubView들이 화면상에서 그려지는 위치가 변경 됨을 의미한다.
- SubView들의 Frame 값을 변화시키는게 아니라 부모 View 좌표축이 변하면서 SubView가 그려져야하는 위치가 달라졌기 때문.
- ScrollView, TableView 등을 스크롤 할 때 ScrollView.bounds가 변하고, SubView들이 그려지는 위치가 달라지는 것이 대표적인 예

## ViewController의 생명주기
- loadView : 컨트롤러가 관리하는 뷰를 생성. 뷰 컨트롤러가 생성되고 순차적으로 완성되었을때만 호출된다.
- viewDidLoad : 컨트롤러가 뷰의 메모리에 올라간 뒤에 호출된다. 뷰가 생성될 때만 호출된다.
- viewWillAppear : 화면에 뷰가 표시될때마다 호출된다. 이 단계는 뷰는 정의된 바운드를 가지고 있지만 화면 회전은 적용되지 않는다.
- viewWillLayoutSubviews : 뷰 컨트롤러에게 그 자식뷰의 레이아웃을 조정하는 것에 대한 것을 알려주기 위해 호출. 이 메소드는 프레임이 바뀔때마다 호출된다
- viewDidLayoutSubviews : 뷰가 그 자식 뷰의 레이아웃에 영향을 준 것을 뷰 컨트롤러에게 알려주기 위해 호출. 뷰가 그 자식 뷰의 레이아웃을 바꾸고 난 뒤에 추가적인 변경을 하고 싶을 때 사용하는 이벤트 함수
- viewDidAppear : 뷰가 나타났다는 것을 컨트롤러에게 알리는 역할을 수행. 호출되는 시점으로는 뷰가 화면에 나타난 직후에 실행된다.
- viewWillDisAppear : 뷰가 사라지기 직전에 호출되는 함수이다. 뷰가 삭제 되려고 하고 있는 것을 뷰 컨트롤러에게 알린다.
- viewDidDisAppear : 뷰 컨트롤러에게 뷰가 제거되었음을 알린다. 호출시점은 viewWillDisAppear 다음에 호출된다.

## App의 생명주기(AppDelegate)
- Not Running : 앱이 실행되지 않은 상태
- Inactive : 앱이 실행중인 상태. 그러나 아무런 이벤트를 받지 않는 상태
- Active : 앱이 실행중이며 이벤트가 발생한 상태
- Background : 앱이 백그라운드에 있는 상태. 그러나 실행되는 코드가 있는 상태
- Suspened : 앱이 백그라운드에 있고 실행되는 코드가 없는 상태
(Inactive와 Active 상태를 합쳐 Foreground 라고 한다) 

- application(_:didFinishLaunching:) 앱이 처음 시작될 떄 실행
- applicationWillResignActive: 앱이 active 에서 inactive로 이동될 때 실행
- applicationDidEnterBackground: 앱이 background 상태일 때 실행
- applicationWillEnterForeground: 앱이 background에서 foreground로 이동 될때 실행 (아직 foreground에서 실행중이진 않음)
- applicationDidBecomeActive: 앱이 active상태가 되어 실행 중일 때applicationWillTerminate: - 앱이 종료될 때 실행 

## 고차함수(Map, Reduce, Filter)

### Map
- 데이터를 변형하고자 할 때 사용.
- 기존 컨테이너의 값들은 변경되지 않고 새로운 컨테이너를 생성하여 반환한다.
- 코드 재사용이 용이하다.
- 컴파일러 최적화 측면에서 성능이 좋다.
- 다중 스레드 환경에서 하나의 컨테이너에 여러 스레드들이 동시에 변경을 하려고 할 때 예측하지 못한 결과 발생을 방지한다.

### Reduce
- 컨테이너 내부를 하나로 합쳐주는 기능을 한다.
- 정수 배열이라면 전달받은 함수의 연산 결과로 합쳐주고, 문자열 배열이라면 문자열을 하나로 합쳐준다.
- 첫 번째 매개변수를 통해 초기값을 지정할 수 있다.

### Filter
- 컨테이너 내부의 값들을 걸러서 추출하고자 할 때 사용한다
- Filter의 매개변수로 전달되는 함수의 반환 타입은 Bool 타입 이다.
- 반환 값이 true라면 값을 포함하고, false라면 배제하여 map과 마찬가지로 새로운 컨테이너를 생성하여 반환한다.

## 동기(Synchronize)와 비동기(Asyncronize)

### 동기(Synchronize)
- 주어진 명령을 차례대로 처리하되 하나의 업무가 완료될 때 까지는 다른 업무로 넘어가지 않는 방식.
- 중간에 대기하는 시간 때문에 효율은 떨어지나 일관된 업무 보장과 동시다발적 업무가 발생하지 않으므로 대응이 불필요하여 업무구성이 단순화된다.

### 비동기(Asyncronize)
- 주어진 명령을 차례대로 처리하되 시간이 걸리는 업무는 진행해둔채 기다리는 동안 다른 업무를 처리하는 방식
- 일관적인 업무 흐름이 깨지고 응답에 대한 대응이 필요하다.

## 스레드
- 하나의 프로세스 내에서 실행되는 작업흐름의 단위.
- 프로세스가 시작하는 동시에 동작하는 스레드를 메인 스레드라고 하고 이외의 추가로 생성되는 스레드를 서브 스레드라고 부른다.

## 멀티 스레드
- 여러개의 스레드가 동시에 진행되는 것을 의미한다.
- 하나의 프로세스 내에서 여러개의 스레드가 존재하고, 스레드들이 프로세스의 자원을 공유하되 실행은 독립적으로 이루어지는 구조.

## 병렬성(Concurrency) 작업을 위해 IOS에서 지원하는 API

### GCD(Grand Central Dispatch)
- Multicore Process를 위한 Thread programming의 방법이다.
- 스레드를 관리하면서 동시적으로 작업을 실행시키는 애플이 제공하는 저수준 API를 제공하는 라이브러리이다.
- 기본적으로 스레드 풀의 관리를 프로그래머가 아닌 운영체제에서 관리하기 때문에 프로그러머가 작업을 비동기적으로 쉽게 사용할 수 있다.
- 프로그래머가 실행할 작업을 생성하고 Dispatch Queue에 추가하면 GCD는 작업에 맞는 스레드를 자동으로 생성해서 실행하고 작업이 종료되면 해당 스레드를 제거한다.

#### 디스패치 대기열(Dispatch Queue)
- 작업을 연속적 혹은 동시에 진행하기는 하지만, 언제나 먼저 들어오면 먼저 나가는 순서로 실행된다.
- Serial Dispatch Queue는 한 번에 하나의 작업만을 실행하며, 해당 작업이 대기열에서 제외되고 새로운 작업이 시작되기 전까지 기다린다.
- Concurrent Dispatch Queue는 이미 시작된 작업이 완료될 때까지 기다리지 않고 가능한 많은 작업을 진행한다.
- 디스패치 대기열은 GCD 기술 일부이다.

### NSOperation 
- NSOperation은 어떤 하나의 작업을 나타낸다.
- 모델링 상태, 우선순위, 의존성, 관리를 지원하는 유용하고 Thread safe한 추상 클래스이다.
- 예를들어 네트워크 요청, 이미지 리사이즈, 텍스트 처리, 기타 다양한 반복처리 등 오래걸리는 작업을 처리해야하는 NSOperation가 있다고 할 때 특정 작업이 담겨있는 객체는 감독 없이 많은 일을 할 수 없는데, 이러한 작업을 진행하는 감독을 NSOperationQueue가 담당한다.

## 동시성 프로그래밍, 병렬성 프로그래밍

### 동시성 프로그래밍
- 동시에 여러 프로그램을 돌리는 것이 아닌 그렇게 보이게끔 하는 기법이다.
- 시간을 분할하여 스레드들에게 서로 번갈아가며 제공하여 실행되게끔 하는 방식.
- 코어에 상관 없이 실행 가능한 기법으로 싱글 코어에서도 멀티 스레딩을 가능하게 한다.

### 병렬성 프로그래밍
- 동시에 돌아가는 것처럼 보이는 것이 아닌 실제로 동시에 실행되는 것을 의미한다.
- 멀티 코어에서 멀티 스레드를 동작시키는 방식으로 데이터 병렬성과 작업 병렬성으로 나뉘게 된다.
- 데이터 병렬성 : 처리해야 할 데이터를 나누어 나누어진 데이터들을 병렬 처리하여 작업을 빠르게 수행하는 기법
- 작업 병렬성 : 서로 다른 작업을 처리하는 기법

## 동시성, 병렬성
- 동시성 프로그래밍, 병렬성 프로그래밍 모두 비동기적으로 구현 가능

### 동시성
- 논리적
- 동시에 실행되는 것처럼 보이는 것
- 싱글코어, 멀티코어에서 가능

### 병렬성
- 물리적
- 실제로 작업이 동시에 처리된다.
- 멀티코어에서만 가능

## 디자인 패턴

### MVC
- Model + View + Controller

### MVP
- Model + View + Presenter
- Model과 View는 MVC 패턴과 동일하고, Controller 대신 Presenter가 존재

- Model : 어플리케이션에서 사용되는 데이터와 그 데이터를 처리하는 부분
- View : 사용자에서 보여지는 UI 부분
- Presenter : View에서 요청한 정보로 Model을 가공하여 View에 전달해 주는 부분

### MVVM


### VIPER

