# IOS 정보 


## ARC(Automatic Reference Counting)
- 자동 참조 계수라고 하며 앱의 메모리 사용을 추적하고 관리하기 위해 사용한다.
- ARC는 인스턴스가 더이상 필요가 없을 때 클래스 인스턴스에 사용된 메모리를 자동적으로 해제한다.
- 코드를 빌드(컴파일) 할때 특정 객체의 레퍼런스 카운트를 추적하여 0 가 되는 시점에 자동으로 release 코드를 넣어주는것을 말한다.
- 컴파일 시점에 동작한다.

## strong, weak, unowned

### strong(강한 참조)
- 이 키워드로 선언된 레퍼런스 객체는 할당되는 순간 해당 객체의 레퍼런스 카운트를 증가시킨다.
- 레퍼런스 카운트를 증가시켜 ARC로 인한 메모리 해제를 피하고 객체를 안전하게 사용하기 위해 쓰인다.
- 값 지정 시점에 retain이 되고 참조가 종료되는 시점에 release가 된다.

### weak(약한 참조)
- 객체를 소유하지 않고 주소값만을 가지고 있는 포인터 개념이다.
- 객체가 할당될 때 레퍼런스 카운트를 증가시키지 않는다.
- 이 키워드는 Optional 타입에만 적용이 된다.
- 객체가 ARC 에 의해 메모리해제되면 nil 값이 할당된다.
- 대표적으로 retain cycle 에 의해 메모리가 누수되는 문제를 막기 위해 사용됨, iOS 프레임워크에서 이의 대표적인 예로는 Delegate 패턴이 있다.

### unowned(미소유 참조)
- 객체가 할당될 때 레퍼런스 카운트를 증가시키지 않는다.
- Non-Optional 타입으로 선언되어야 한다.
- 객체가 ARC에 의해 메모리가 해제되더라도 해당 객체 값을 존재하는 것으로 인지, 해당 객체에 엑세스 할 경우 런타임 오류를 발생시킨다.

## 객체간 순환참조를 발견하는 방법과 해결방법
- Xcode Memory Graph 이용해서 Live Object 들을 확인하고, Leak 된 Object 를 체크.
- Instrument 의 Leak 도구를 이용하여 체크.
- deinit 을 활용하여 로깅코드를 통해 체크.

## Escaping Closure
- 클로저가 함수로부터 Escape 한다는 것은 해당 함수의 인자로 클로저가 전달되지만, 함수가 반환된 후 실행되는것을 의미.
- 클로저를 매개변수로 갖는 함수를 선언할 때 매개 변수의 이름의 콜론 뒤에 @escaping 키워드를 사용하여 클로저가 탈출하는 것을 허용한다고 명시
- 클로저가 함수를 탈출할 수 있는 경우 중 하나는 함수 외부에 정의된 변수나 상수에 저장되어 함수가 종료된 후에 사용할 경우.
- 비동기 작업을 해야하는 많은 함수들은 completion handler 매개변수로 클로저를 받는다. 해당 클로저는 함수의 작업이 완료될 때 까지 호출되지 않는다. 즉, completion handler 는 함수의 작업이 완료된 후 호출되는 것을 보장받을 수 있다.
- @escaping으로 표기된 클로저는 외부 값을 참조할 때 self 를 명시해야 합니다.

## 타입캐스팅 as, as!, as?

### as
- 컴파일러가 타입 변환의 성공을 보장한다.
- 컴파일 타임에 가능/불가능 여부를 알 수 있다.

### as!
- 타입 변환에 실패하는 경우 실행시간(Runtime)오류를 발생시킨다.
- 컴파일 타임에  가능/불가능 여부를 알 수 없다.

### as?
- 타입 변환에 실패하는 경우 nil을 리턴
- 컴파일 타임에 가능/불가능 여부를 알 수 없다.

## Class와 Struct
### Class
- Reference Type
- 객체화 시 힙 메모리 영역에 저장되며 ARC로 객체의 메모리해제가 관리된다.
- 대입 연산 시 레퍼런스가 복사되어 할당된다. (공유가 가능하다)
- 멀티스레딩 시 적절한 Lock활용이 필요하다.
- 상속이 가능하다.

### Struct
- Value Type
- 대입 연산 시 값 자체가 복제되어 할당된다. (공유가 불가능하다)
- 불변성 구현에 유리하다.
- 멀티스레딩에 안전하다.
- 상속이 불가능하다. (protocol은 사용가능)

## Frame과 Bounds

### Frame
- SuperView(상위뷰) 좌표시스템 내에서의 View의 위치와 크기

### Bounds
- View 자기 자신의 좌표시스템에서의 위치와 크기
- 부모 View와의 위치관계와는 아무런 관계가 없다.
- 자기자신의 좌표시스템을 가리키기 때문에 기본적으로 origin은 x:0, y:0을 가리킨다.
- Bounds의 origin을 변경한다는 것은 SubView들이 화면상에서 그려지는 위치가 변경 됨을 의미한다.
- SubView들의 Frame 값을 변화시키는게 아니라 부모 View 좌표축이 변하면서 SubView가 그려져야하는 위치가 달라졌기 때문.
- ScrollView, TableView 등을 스크롤 할 때 ScrollView.bounds가 변하고, SubView들이 그려지는 위치가 달라지는 것이 대표적인 예




